#!/opt/rb/var/www/snorby/script/rails runner
#
# Copyright (c) 2011 redBorder Networks
# Authors: 
# 	Pablo Nebrera Herrera  pablonebrera@eneotecnologia.com
#	Juan Jesus Prieto:     jjprieto@eneotecnologia.com
#	Jose Antonio Parra:    japarra@eneotecnologia.com
#
#  Description:
#	It reads the configuration from config/rules2rbIPS.yml. Format:
#		verbose: false
#		cache_dir: "/opt/rb/var/www/snortrules/cache"
#		url_rules:
#		  -
#		    name: "emergingthreats" 
#		    domain: "https://rules.emergingthreats.net"
#		    tgz: "https://rules.emergingthreats.net/open/snort-2.9.1/emerging.rules.tar.gz"
#		    md5: "https://rules.emergingthreats.net/open/snort-2.9.1/emerging.rules.tar.gz.md5"
#		    search:
#		      - "rules"
#
###########################################################################################################	

# Example of use:
#   ./script/rules2rbIPS -D     -> execute it in verbose mode 
#   ./script/rules2rbIPS -Df    -> execute it in verbose mode and force an update 
#   ./script/rules2rbIPS -Dd path_to_rules_directory  -> execute it reading the rules from the directory

require 'getopt/std'
require 'yaml'
require 'net/http'
require 'tempfile'
require 'digest/md5'

def downloadFile(domain, url, local_file)
  uri = URI.parse(url)
  http = Net::HTTP.new(uri.host, uri.port)
  if uri.scheme == "https"
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    #http.verify_mode = OpenSSL::SSL::VERIFY_PEER
    #http.ca_file = File.join(File.dirname(__FILE__), "cacert.pem")
  end

  http.start do |http|
    resp = http.get(url)
    open(local_file, "wb") do |file|
      file.write(resp.body)
    end
  end
end

timenow   = Time.now

config = YAML.load_file("/opt/rb/var/www/snorby/config/rules2rbIPS.yml")
opt = Getopt::Std.getopts("d:Df")
config["verbose"]   = true     if opt["D"]
config["verbose"]   = false    if config["verbose"].nil?
config["cache_dir"] = "/opt/rb/var/www/snortrules/cache" if config["cache_dir"].nil?

includeRuleDir = []
if opt["d"]
  source = RuleSource.first(:name => "local")
  source = RuleSource.create(:name => "local") if source.nil?
  source.update(:timestamp => timenow)
  includeRuleDir << {:name => "local", :dir => opt["d"], :id => source.id}
end

if opt["f"]
  config["force"] = true
else
  config["force"] = false
end

printf("Starting rule2rbIPS\n") if config["verbose"]
newRules=false

#Download rules
unless config["url_rules"].nil?
  config["url_rules"].each do |rule_source|
    begin
      unless rule_source["name"].nil?
        if rule_source["tgzfile"].nil?
          tgzLocalFile = "#{config["cache_dir"]}/#{rule_source["name"]}.tgz"
        else
          tgzLocalFile = rule_source["tgzfile"]
        end

        dFile      = true
        dLocalFile = false

        if File.exists?(tgzLocalFile)
          md5Content = ""
          md5LocalFile = "#{config["cache_dir"]}/#{rule_source["name"]}.md5"
          if !rule_source["md5"].nil? && !rule_source["domain"].nil?
            printf("Downloading #{rule_source["md5"]}\n") if config["verbose"]
            downloadFile(rule_source["domain"], rule_source["md5"], md5LocalFile)
            md5Content      = File.open(md5LocalFile).first.chop
            localMd5Content = Digest::MD5.hexdigest(File.read(tgzLocalFile));
            rule_source[:md5_value] = md5Content

            if (localMd5Content==md5Content)
              printf("The local file #{tgzLocalFile} is the same than remote file. ") if config["verbose"]
              printf("Ignoring it!!") if config["verbose"] && !config["force"]
              printf("\n") if config["verbose"]
              dFile = false
            end
          else
            dLocalFile = true
            dFile      = false
          end
        end

        if (dFile || dLocalFile || config["force"])
          if dFile
            printf("Downloading #{rule_source["tgz"]}\n") if config["verbose"]
            downloadFile(rule_source["domain"], rule_source["tgz"], tgzLocalFile)
          end

          #Extracting rules
          if File.exists?(tgzLocalFile)
            dirExtract = "#{config["cache_dir"]}/#{rule_source["name"]}"
            `rm -rf #{dirExtract}` if File.directory? dirExtract
            `mkdir #{dirExtract}`
            printf("Extracting #{tgzLocalFile}\n") if config["verbose"]
            `tar xzf #{tgzLocalFile} -C #{dirExtract}`
            newRules=true
          end
        end
      end
    rescue => err
      printf("Error with the url #{rule_source["name"]} (#{err})\n")
    end
  end
end

if newRules
  config["url_rules"].each do |rule_source|
    source = RuleSource.first(:name => rule_source["name"])
    source = RuleSource.create(:name => rule_source["name"], :timestamp => timenow) if source.nil?
    source.update(:md5 => rule_source[:md5_value], :timestamp => timenow)
    rule_source["search"].each do |rs|
      includeRuleDir << {:name => rule_source["name"], :dir => "#{config["cache_dir"]}/#{rule_source["name"]}/#{rs}", :id => source.id, :regexp_category1_ignore => rule_source["regexp_category1_ignore"], :regexp_category2_ignore => rule_source["regexp_category2_ignore"], :regexp_category3_ignore => rule_source["regexp_category3_ignore"], :md5_value=>rule_source[:md5_value], :category3_groups => rule_source["category3_groups"] }
    end
  end
end

dbVersion = RuleDbversion.create(:timestamp => timenow ) unless includeRuleDir.blank?

includeRuleDir.each do |rulesDir|
  printf("Processing %s rules (%s)\n", rulesDir[:name], rulesDir[:dir]) if config["verbose"]
  if !Dir.exist?(rulesDir[:dir])
    printf("    - Directory %s does not exist. Ignoring it!!\n", rulesDir[:dir]) if config["verbose"]
  else
    Rule.transaction do |t|
      begin 
        rulesDirectory = Dir.open(rulesDir[:dir])
        pathRulesDir   = rulesDirectory.to_path

        rulesDirectory.to_a.each do |file|
          next if file == "." or file == ".."
          next unless file =~ /\.rules$/
          ruleFile = pathRulesDir + "/" + file
          category1 = file.gsub(".rules","").strip.downcase
          category1 = category1.gsub /#{rulesDir[:regexp_category1_ignore]}/, "" unless rulesDir[:regexp_category1_ignore].nil?

          category1_tmp = category1

          unless config["category1_groups"].nil?
            config["category1_groups"].each do |catgr|
              unless /#{catgr["regexp"]}/.match(category1).nil?
                category1_tmp = catgr["name"]
                break
              end
            end
          end

          rc1 = RuleCategory1.first(:name => category1_tmp)
          rc1 = RuleCategory1.create(:name=> category1_tmp) if rc1.nil?

          category4=nil
          category4_desc=nil
          unless config["category4_groups"].nil?
            config["category4_groups"].each do |catgr|
              unless /#{catgr["regexp"]}/.match(category1_tmp).nil?
                category4      = catgr["name"]
                category4_desc = catgr["desc"]
                break
              end
            end
          end

          category4="others" if category4.nil?
          rc4 = RuleCategory4.first(:name => category4)
          rc4 = RuleCategory4.create(:name=> category4) if rc4.nil?
          rc4.update(:description => category4_desc) unless category4_desc.nil?

          ruleFile = File.open(ruleFile)

          while ruleLine = ruleFile.gets
            ruleLine.chop!
            ruleMatch = /^(?<action>\w+)\s+(?<l3l4>(?<protocol>\w+)\s+(?<source_addr>[^\s]+)\s+(?<source_port>[^\s]+)\s+->\s+(?<target_addr>[^\s]+)\s+(?<target_port>[^\s]+)\s+)?\((?<rule>.+)\)\s*$/.match(ruleLine)
            unless ruleMatch.nil?

              #variables
              unless ruleMatch[:protocol].nil?
                vars = (ruleMatch[:source_addr] +" " +ruleMatch[:target_addr]).scan(/\$([^ ,;]*)/)
                vars.each do |x|
                  var = RuleVariable.first(:name => x[0], :type=>RuleVariable::IPVAR)
                  var = RuleVariable.create(:name=> x[0], :type=>RuleVariable::IPVAR) if var.nil?
                end
                vars = (ruleMatch[:source_port] +" " +ruleMatch[:target_port]).scan(/\$([^ ,;]*)/)
                vars.each do |x|
                  var = RuleVariable.first(:name => x[0], :type=>RuleVariable::PORTVAR)
                  var = RuleVariable.create(:name=> x[0], :type=>RuleVariable::PORTVAR) if var.nil?
                end
              end

              sidRuleMatch = /; sid:\s*(?<sid>\d+);/.match(ruleMatch[:rule])
              unless sidRuleMatch.nil?
                msgRuleMatch = /msg:\s*"(?<msg>[^"]+)";/.match(ruleMatch[:rule])
                unless msgRuleMatch.nil?	
                  classtypeRuleMatch = /; classtype:\s*(?<classtype>[^;]+);/.match(ruleMatch[:rule])
                  if classtypeRuleMatch.nil?
                    category2="unknown"
                  else
                    category2 = classtypeRuleMatch[:classtype].strip.downcase
                    category2 = category2.gsub /#{rulesDir[:regexp_category2_ignore]}/, "" unless rulesDir[:regexp_category2_ignore].nil?
                  end

                  rc2 = RuleCategory2.first(:name => category2)
                  rc2 = RuleCategory2.create(:name=>category2) if rc2.nil?

                  rule_msg = msgRuleMatch[:msg].downcase
                  rule_msg = rule_msg.gsub /#{rulesDir[:regexp_category3_ignore]}/, "" unless rulesDir[:regexp_category3_ignore].nil?
                  rule_msg = rule_msg.gsub /^#{category1} /, ""

                  category3=nil

                  unless rulesDir[:category3_groups].nil?
                    rulesDir[:category3_groups].each do |catgr|
                      unless /#{catgr["regexp"]}/.match(rule_msg).nil?
                        category3 = catgr["name"]
                      end
                    end                   
                  end

                  if category3.nil?
                    category3RuleMatch = /([^ _-]*([ _-][^ _-]*)?([ _-][^ _-]*)?)/.match(rule_msg)
                    if category3RuleMatch.nil?
                      category3="unknown"
                    else
                      category3 = category3RuleMatch[0][0..63].strip
                    end
                  end

                  rc3 = RuleCategory3.first(:name => category3)
                  rc3 = RuleCategory3.create(:name=>category3) if rc3.nil?

                  revRuleMatch = /; rev:\s*(?<value>\d+);/.match(ruleMatch[:rule])
                  rev = revRuleMatch.nil? ? 0 : revRuleMatch[:value].to_i

                  gidRuleMatch = /; gid:\s*(?<value>\d+);/.match(ruleMatch[:rule])
                  gid = gidRuleMatch.nil? ? 1 : gidRuleMatch[:value].to_i

                  r = Rule.new()
                  r.rule_id      = sidRuleMatch[:sid].to_i
                  r.msg          = msgRuleMatch[:msg]
                  r.category1_id = rc1.id
                  r.category2_id = rc2.id
                  r.category3_id = rc3.id
                  r.category4_id = rc4.id
                  r.protocol     = ruleMatch[:protocol]
                  r.source_addr  = ruleMatch[:source_addr]
                  r.source_port  = ruleMatch[:source_port]
                  r.target_addr  = ruleMatch[:target_addr]
                  r.target_port  = ruleMatch[:target_port]
                  r.rev          = rev.to_i
                  r.gid          = gid.to_i
                  r.dbversion_id = dbVersion.id
                  r.rule         = ruleMatch[:rule]
                  r.source_id    = rulesDir[:id]

                  #printf("    - rule sid: %d\n", r.rule_id) if config["verbose"]

                  if !r.save && config["verbose"]
                    printf("The rule has not been saved: \n   Rule: %s\n   Errors:%s\n\n", ruleLine, r.errors.inspect);
                  end
                else
                  printf("MSG not found!! \n%s\n", ruleLine) if config["verbose"]
                end
              else 
                printf("SID not found!! \n%s\n", ruleLine) if config["verbose"]
              end
            else
              #printf("rule line doesn't match!! \n%s\n", ruleLine) if config["verbose"]
            end
          end
          ruleFile.close
        end

        rulesDirectory.close

      rescue DataObjects::Error => e
        printf("An error has finalized the transaction. #{e.to_s}\nRolling back\n")
	newRules=false
        p e
        t.rollback
      end
    end
  end
end  

if newRules
  dbVersion.completed = true;
  dbVersion.save
end
printf("Exiting successfully!\n") if config["verbose"]
